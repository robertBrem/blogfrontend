<div class="col-sm-7" ng-controller="AboutMeCtrl">

    <div class="row">
        <div class="col-xs-12">
            <h1>Getting started with Docker - Set up</h1>

            <p>by Robert Brem</p>
            <small>
                <span class="glyphicon glyphicon-time"></span>
                01.05.2015 at 00:00
            </small>

            <hr/>

            <p class="lead">
                In this series I’ll show you how to implement a Microservice with Docker. The final Microservice
                consist of a database and expose its functionality over a REST service. In this entry in particular
                I’ll explain what a Microservice in my view is and give additional sources for more information about
                Microservices. Furthermore I’ll demonstrate how to set up Docker and show some basic Docker commands.
            </p>

            <div>
                <h2>What are Microservices?</h2>
                If you are not interested in the basic you can just skip this part and go directly to Install Docker
                and start with the set up.<br/>
                What a Microservice is differs from person to person. In my opinion a Microservice has to…
                <ul>
                    <li> … achieve the Single Responsibility Principle</li>
                    <li> … be loosely coupled</li>
                    <li> … communicate over a simple not technology bounded style</li>
                </ul>
                For our first Microservice we choose Java EE and Postgres as the technology for this single service. As
                underlying base technologies for the whole system we choose Docker that allows us to implement the
                services extremely loosely coupled. Every service runs in his own operation system. The communication
                between the services is in REST, because REST is a lot simpler than SOAP. Another advantage of REST over
                SOAP is that it fits perfectly with mobile devices and Internet of Things. This results in the following
                architecture for a single Microservice.
                <img src="https://github.com/robertBrem/microservicesAndDocker/raw/master/images/microservicesWithDocker14.png"
                     alt="Architecture of a Microservice"/>
                The benefit of this architecture is that it is easy to scale because every service is loosely coupled
                and therefore can be replicated and set behind a load balancer. This has more pros than just speed up
                the application if there are performance issues. With Microservices it is possible to make continuous
                deployment on a subset of nodes. If you have a service in version 1.0 and it runs with five replicas
                you can deploy a change instantly as version 1.1 on one of this five replicas. The new change is now
                just visible for a subset of the users. A circuit breaker can than handle problems with this replica
                and exclude this replica if it has errors. If the new service is technically running failure free you
                can make business monitoring and compare version 1.0 and version 1.1 of the service. Fred George
                explains in his presentation that business monitoring is the best and only representative way to
                make acceptance tests. With a proper monitoring it is really simple to evaluate which service produced
                more profit or on which service the people stayed for a longer time.<br/>
                Another plus for this architecture is the fact that the programmer can choose his on technology for
                implementing his service. Adrian Cockcroft explains in his presentation that the programmers wrote
                cleaner code because Netflix make all his service open source. The name of the programmer is now
                linked for everyone directly to code that represents him. I think even the fact that the programmer
                can choose his own style to implement the service has this effect. If an architect tells you
                (the programmer) how you have to implement it you feel less responsible for this part.<br/>
                Moreover the loosely coupled system makes your system very resilient. A service can horrible crash and
                it just affects this single service. The system is still working expect this part. If the same happens
                with a monolithic application the whole system will go down.<br/>
                But Microservices are no silver bullet. This architecture raises a lot of questions that are harder to
                solve than in a monolithic application like:
                <ul>
                    <li>Lightweight Runtime</li>
                    <li>Transaction Management</li>
                    <li>Service Scaling</li>
                    <li>Load Balancing</li>
                    <li>Deployment</li>
                    <li>Configuration</li>
                    <li>Monitoring</li>
                    <li>Failure Handling</li>
                    <li>Logging</li>
                    <li>Security</li>
                </ul>
                The biggest issue is from my point of view is the lightweight runtime. If you have to set up the whole
                loosely coupled environment manually for every Microservice you would not be happy. The solution is,
                like you already know, Docker!
                <h2>Install Docker</h2>
                Docker is based on LXC (Linux Containers) and therefore you have to have a Linux operating system. This
                can be your host system or run in a virtual machine. Docker also have boot2docker that can be used from
                Mac and Windows users. Since Docker version 1.6 there is also a Windows Client.<br/>
                I take the virtual machine approach because I make a virtual machine for every new project that I start
                anyway. I have set up a Virtual Box with Ubuntu 14.04.2 64bit.<br/>
                To install Docker you just have execute the following line:
                <span hljs language="diff">
apt-get update
wget -qO- https://get.docker.com/ | sh</span>
                To test if every think worked correctly you can run the following statement:
                <span hljs language="diff">
docker version</span>
                This should result in something like:
                <span hljs language="diff">
Client version: 1.6.0
Client API version: 1.18
Go version (client): go1.4.2
Git commit (client): 4749651
OS/Arch (client): linux/amd64
Server version: 1.6.0
Server API version: 1.18
Go version (server): go1.4.2
Git commit (server): 4749651
OS/Arch (server): linux/amd64</span>

                <h2>Getting started with Docker</h2>
                Our first container that we will start is a Fedora Linux.
                <span hljs language="diff">
docker run -it fedora bash</span>
                <code>docker run fedora</code> tells Docker to start a container with the image fedora. We never
                have downloaded or installed the fedora image. Therefore Docker has to pull the fedora image from the
                Docker Hub. If you need a new image Docker Hub is a good starting point so search if somebody already
                made a Docker image that correspond to our use case.<br/>
                The <code>–it</code> parameter tells Docker to start the container interactive (<code>i</code>) and with
                a terminal (<code>t</code>), because we would test the container, this is needed. Later we will see,
                that we also can start a container in the background without interaction.<br/>
                The last parameter <code>bash</code> tells Docker to open the bash in the container that we can start
                working directly inside the container.<br/>
                This command should result in:
                <span hljs language="diff">
Unable to find image 'fedora:latest' locally
latest: Pulling from fedora
48ecf305d2cf: Pull complete
93be8052dfb8: Already exists
fedora:latest: The image you are pulling has been verified. Important: image verification is a tech
preview feature and should not be relied on to provide security.
Digest: sha256:c63476a082b960f6264e59ef0ff93a9169eac8daf59e24805e0382afdcc9082f
Status: Downloaded newer image for fedora:latest
bash-4.3#</span>
                You can now test if you really have now a Fedora Linux by typing the following command:
                <span hljs language="diff">
cat /etc/*-release</span>
                This should result in:
                <span hljs language="diff">
Fedora release 21 (Twenty One)
NAME=Fedora
VERSION="21 (Twenty One)"
ID=fedora
VERSION_ID=21
PRETTY_NAME="Fedora 21 (Twenty One)"
ANSI_COLOR="0;34"
CPE_NAME="cpe:/o:fedoraproject:fedora:21"
HOME_URL="https://fedoraproject.org/"
BUG_REPORT_URL="https://bugzilla.redhat.com/"
REDHAT_BUGZILLA_PRODUCT="Fedora"
REDHAT_BUGZILLA_PRODUCT_VERSION=21
REDHAT_SUPPORT_PRODUCT="Fedora"
REDHAT_SUPPORT_PRODUCT_VERSION=21
Fedora release 21 (Twenty One)
Fedora release 21 (Twenty One)</span>
                If you execute the same command in another console on your guest virtual machine:
                <span hljs language="diff">
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=14.04
DISTRIB_CODENAME=trusty
DISTRIB_DESCRIPTION="Ubuntu 14.04.2 LTS"
NAME="Ubuntu"
VERSION="14.04.2 LTS, Trusty Tahr"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 14.04.2 LTS"
VERSION_ID="14.04"
HOME_URL="http://www.ubuntu.com/"
SUPPORT_URL="http://help.ubuntu.com/"
BUG_REPORT_URL=http://bugs.launchpad.net/ubuntu/</span>
                Now we start working in our container we go create a file in the folder temp:
                <span hljs language="diff">
cd /tmp/
touch optimist.expert
ls</span>
                This should output the following:
                <span hljs language="diff">
anaconda-post.log ks-script-NwsqGK optimist.expert yum.log</span>
                We can see our file <code>optimist.expert</code> is in the folder <code>/tmp</code>. Now we close our
                container with exit.
                <span hljs language="diff">
exit</span>
                We are now back in our guest operating system and can check if our container is still running. You can
                achieve that by typing:
                <span hljs language="diff">
docker ps</span>
                That results in:
                <span hljs language="diff">
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span>
                Which means there is no container running. Why did Docker shut down our container when we exit it? That
                is because we said Docker we start our container with the bash. This means Docker let the container run
                as long as the bash command is running, you can start and stop other programs that is no problem, but as
                soon as you exit your bash Docker shut down the container. The container is not removed it is just
                stopped you can check that by typing the following:
                <span hljs language="diff">
docker ps –a</span>
                Here you can find your container in the state Exited.
                <span hljs language="diff">
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
18e3c31489c2 fedora:latest "bash" 8 minutes ago Exited (0) 7 minutes ago pensive_pike</span>
                Now you can restart this container by typing:
                <span hljs language="diff">
docker start pensive_pike</span>

                <div>
                    Hint: The name of your container is perhaps not the same as mine (<code>pensive_pike</code>) this,
                    name get automatically generated by Docker. Another possibility is to use the id of the container
                    instead of the name. In this case this would be <code>18e3c31489c2</code>.
                </div>
                Then you start the same container but in the background. If you would work inside the container again
                you can do that with the exec command of Docker:
                <span hljs language="diff">
docker exec -it pensive_pike bash</span>
                Now you are back in the container. You can check if your file is still there:
                <span hljs language="diff">
ls /tmp</span>
                Results in:
                <span hljs language="diff">
anaconda-post.log ks-script-NwsqGK optimist.expert yum.log</span>
                Perfect! Everything is working like expected. Now we leave our container again:
                <span hljs language="diff">
Exit</span>
                And now we check if Docker has shut down our container again:
                <span hljs language="diff">
docker ps</span>
                Give you the following output:
                <span hljs language="diff">
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
18e3c31489c2 fedora:latest "bash" 15 minutes ago Up 4 minutes pensive_pike</span>
                Our container is still running? But why? I have closed the bash with exit like before!?! That is
                correct, but to jump inside your container you have opened an additional bash. Not the same like the
                bash the container was started with. Like I told earlier it is no problem to start and stop other
                programs as long as the command you started the container with is still running.<br/>
                But how can I stop my container now if I do not want it to run anymore? This can be done by the Docker
                stop command:
                <span hljs language="diff">
docker stop pensive_pike</span>
                Now you have no more running containers:
                <span hljs language="diff">
docker ps</span>
                Results in:
                <span hljs language="diff">
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span>
                But how can I remove the container if I do not need it anymore? This can be done by the Docker remove
                (<code>rm</code>) command:
                <span hljs language="diff">
docker rm pensive_pike</span>
                If you now check your containers with:
                <span hljs language="diff">
docker ps –a</span>
                <span hljs language="diff">
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span>
                There is no more container!<br/>
                But what does that mean I have to download the image again from Docker Hub if I want to start a Fedora
                image again?<br/>
                Let’s test it by starting a fedora container again like at the beginning:
                <span hljs language="diff">
docker run -it fedora bash</span>
                This was amazing fast, no way that Docker had downloaded the image and started the container in less
                than a second. It is still amazing that it can start the container in less than a second compared to
                virtual machines :-)<br/>
                We have to distinguish between containers and images. You can start multiple contains of the same image
                and you can stop and remove containers of an image and the image does not get deleted. But the images
                are read only. So if you check now if your file is still available…
                <span hljs language="diff">
ls /tmp</span>
                Results in:
                <span hljs language="diff">
anaconda-post.log ks-script-NwsqGK yum.log</span>
                It is not there anymore. I will describe later in another post how to persist data from containers on
                your underlying operating system that you can stop and remove containers and still have your data.
                Now exit this Fedora again:
                <span hljs language="diff">
exit</span>
                How can I see which images I have downloaded? You can achieve that with the following command:
                <span hljs language="diff">
docker images</span>
                That results in:
                <span hljs language="diff">
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
fedora latest 93be8052dfb8 9 days ago 241.3 MB</span>
                Docker images work like Lego bricks you can staple them. For example you want a container that runs a
                Wildfly application server you start with a Fedora base image. Then you create another image that builds
                up of you fedora image and installs Java. Another image builds up of your Java image and installs
                Wildfly. This bricks are not displayed in this view. To display all images, including the underlying
                images, you have to type:
                <span hljs language="diff">
docker images –a</span>
                That results in:
                <span hljs language="diff">
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
fedora latest 93be8052dfb8 9 days ago 241.3 MB
&lt;none&gt;  &lt;none&gt; 48ecf305d2cf 9 days ago 0 B</span>
                You can remove an image but first you have to stop and remove all containers that use this
                image. The following command stops and removes all your Docker containers:
                <span hljs language="diff">
docker stop $(docker ps -a -q) && docker rm $(docker ps -a -q)</span>
                Now you can remove the image as well:
                <span hljs language="diff">
docker rmi fedora</span>
                If you want to remove all images you can achieve that with:
                <span hljs language="diff">
docker rmi -f images $(docker images -a -q)</span>

                <h2>Debugging Docker</h2>
                Not everything is always working like the hello world tutorial and therefore we need tools for
                debugging. One tool we have learned already, the Docker exec command.
                <span hljs language="diff">
docker exec –it {container name or id} bash</span>
                In the real world we start our container in the background and not interactive. But if the
                container is not working correctly we have to check what is going on in the container.
                This just works if the container is still running. But what is when my container cannot start?
                Then you can use the Docker logs command:
                <span hljs language="diff">
docker logs {container name or id}</span>
                This results in:
                <span hljs language="diff">
bash-4.3# exit
exit</span>
                If you start a Wildfly container and it cannot start because the start script of Wildfly failed.
                This command would print out the log of the Wildfly console.<br/>
                You can also set the name of the container by yourself with the Docker name argument:
                <span hljs language="diff">
docker run –it –name optimist_fedora fedora bash</span>
                A name chosen by yourself is always easier to remember than a generated name or id :-)<br/>
                If a container is running and you need some information about the Docker container settings. For
                example what is the ip of this container you can achieve that with the Docker inspect command:
                <span hljs language="diff">
docker inspect {container name or id}</span>
                That results in:
                <span hljs language="json">
[
  {
    "AppArmorProfile": "",
    "Args": [

    ],
    "Config": {
      "AttachStderr": true,
      "AttachStdin": true,
      "AttachStdout": true,
      "Cmd": [
        "bash"
      ],
      "CpuShares": 0,
      "Cpuset": "",
      "Domainname": "",
      "Entrypoint": null,
      "Env": null,
      "ExposedPorts": null,
      "Hostname": "f00cd5b86d20",
      "Image": "fedora",
      "Labels": {

      },
      "MacAddress": "",
      "Memory": 0,
      "MemorySwap": 0,
      "NetworkDisabled": false,
      "OnBuild": null,
      "OpenStdin": true,
      "PortSpecs": null,
      "StdinOnce": true,
      "Tty": true,
      "User": "",
      "Volumes": null,
      "WorkingDir": ""
    },
    "Created": "2015-05-01T12:21:05.554155979Z",
    "Driver": "aufs",
    "ExecDriver": "native-0.2",
    "ExecIDs": null,
    "HostConfig": {
      "Binds": null,
      "CapAdd": null,
      "CapDrop": null,
      "CgroupParent": "",
      "ContainerIDFile": "",
      "CpuShares": 0,
      "CpusetCpus": "",
      "Devices": [

      ],
      "Dns": null,
      "DnsSearch": null,
      "ExtraHosts": null,
      "IpcMode": "",
      "Links": null,
      "LogConfig": {
        "Config": null,
        "Type": "json-file"
      },
      "LxcConf": [

      ],
      "Memory": 0,
      "MemorySwap": 0,
      "NetworkMode": "bridge",
      "PidMode": "",
      "PortBindings": {

      },
      "Privileged": false,
      "PublishAllPorts": false,
      "ReadonlyRootfs": false,
      "RestartPolicy": {
        "MaximumRetryCount": 0,
        "Name": "no"
      },
      "SecurityOpt": null,
      "Ulimits": null,
      "VolumesFrom": null
    },
    "HostnamePath": "\/var\/lib\/docker\/containers\/f00cd5b86d20e50eca0cbc5865f0a40da34763735c6f880957f852347edb7434\/hostname",
    "HostsPath": "\/var\/lib\/docker\/containers\/f00cd5b86d20e50eca0cbc5865f0a40da34763735c6f880957f852347edb7434\/hosts",
    "Id": "f00cd5b86d20e50eca0cbc5865f0a40da34763735c6f880957f852347edb7434",
    "Image": "93be8052dfb86e325563e4f9b8283e4cfaf2a8703569fc6d18c33edade3196fa",
    "LogPath": "\/var\/lib\/docker\/containers\/f00cd5b86d20e50eca0cbc5865f0a40da34763735c6f880957f852347edb7434\/f00cd5b86d20e50eca0cbc5865f0a40da34763735c6f880957f852347edb7434-json.log",
    "MountLabel": "",
    "Name": "\/compassionate_mestorf",
    "NetworkSettings": {
      "Bridge": "docker0",
      "Gateway": "172.17.42.1",
      "GlobalIPv6Address": "",
      "GlobalIPv6PrefixLen": 0,
      "IPAddress": "172.17.0.10",
      "IPPrefixLen": 16,
      "IPv6Gateway": "",
      "LinkLocalIPv6Address": "fe80::42:acff:fe11:a",
      "LinkLocalIPv6PrefixLen": 64,
      "MacAddress": "02:42:ac:11:00:0a",
      "PortMapping": null,
      "Ports": {

      }
    },
    "Path": "bash",
    "ProcessLabel": "",
    "ResolvConfPath": "\/var\/lib\/docker\/containers\/f00cd5b86d20e50eca0cbc5865f0a40da34763735c6f880957f852347edb7434\/resolv.conf",
    "RestartCount": 0,
    "State": {
      "Dead": false,
      "Error": "",
      "ExitCode": 0,
      "FinishedAt": "0001-01-01T00:00:00Z",
      "OOMKilled": false,
      "Paused": false,
      "Pid": 21386,
      "Restarting": false,
      "Running": true,
      "StartedAt": "2015-05-01T12:21:05.642108094Z"
    },
    "Volumes": {

    },
    "VolumesRW": {

    }
  }
]</span>
                This are the basics of Docker I have made a cheat sheet for a quick overview that can be found
                <a href="https://github.com/robertBrem/microservicesAndDocker/blob/master/CheatSheet.md"
                   target="_blank">CheatSheet</a>

            </div>
        </div>

    </div>
</div>